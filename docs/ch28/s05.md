# 5. lseek

每个打开的文件都记录着当前读写位置，打开文件时读写位置是0，表示文件开头，通常读写多少个字节就会将读写位置往后移多少个字节。但是有一个例外，如果以`O_APPEND`方式打开，每次写操作都会在文件末尾追加数据，然后将读写位置移到新的文件末尾。`lseek`和标准I/O库的`fseek`函数类似，可以移动当前读写位置（或者叫偏移量）。

```c
#include <sys/types.h>
#include <unistd.h>

off_t lseek(int fd, off_t offset, int whence);
```

参数`offset`和`whence`的含义和`fseek`函数完全相同。只不过第一个参数换成了文件描述符。和`fseek`一样，偏移量允许超过文件末尾，这种情况下对该文件的下一次写操作将延长文件，中间空洞的部分读出来都是0。

若`lseek`成功执行，则返回新的偏移量，因此可用以下方法确定一个打开文件的当前偏移量：

```c
off_t currpos;
currpos = lseek(fd, 0, SEEK_CUR);
```

这种方法也可用来确定文件或设备是否可以设置偏移量，常规文件都可以设置偏移量，而设备一般是不可以设置偏移量的。如果设备不支持`lseek`，则`lseek`返回-1，并将`errno`设置为`ESPIPE`。注意`fseek`和`lseek`在返回值上有细微的差别，`fseek`成功时返回0失败时返回-1，要返回当前偏移量需调用`ftell`，而`lseek`成功时返回当前偏移量失败时返回-1。 